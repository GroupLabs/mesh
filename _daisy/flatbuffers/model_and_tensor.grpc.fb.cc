// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: model_and_tensor

#include "model_and_tensor_generated.h"
#include "model_and_tensor.grpc.fb.h"

#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace myservice {

static const char* ModelService_method_names[] = {
  "/myservice.ModelService/ReceiveModelAndTensor",
};

std::unique_ptr< ModelService::Stub> ModelService::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& /*options*/) {
  std::unique_ptr< ModelService::Stub> stub(new ModelService::Stub(channel));
  return stub;
}

ModelService::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel)  , rpcmethod_ReceiveModelAndTensor_(ModelService_method_names[0], ::grpc::internal::RpcMethod::CLIENT_STREAMING, channel)
  {}
  
::grpc::ClientWriter< flatbuffers::grpc::Message<InputData>>* ModelService::Stub::ReceiveModelAndTensorRaw(::grpc::ClientContext* context, flatbuffers::grpc::Message<ReceiveModelAndTensorResponse>* response) {
  return ::grpc::internal::ClientWriterFactory< flatbuffers::grpc::Message<InputData>>::Create(channel_.get(), rpcmethod_ReceiveModelAndTensor_, context, response);
}

::grpc::ClientAsyncWriter< flatbuffers::grpc::Message<InputData>>* ModelService::Stub::AsyncReceiveModelAndTensorRaw(::grpc::ClientContext* context, flatbuffers::grpc::Message<ReceiveModelAndTensorResponse>* response, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc::internal::ClientAsyncWriterFactory< flatbuffers::grpc::Message<InputData>>::Create(channel_.get(), cq, rpcmethod_ReceiveModelAndTensor_, context, response, true, tag);
}

::grpc::ClientAsyncWriter< flatbuffers::grpc::Message<InputData>>* ModelService::Stub::PrepareAsyncReceiveModelAndTensorRaw(::grpc::ClientContext* context, flatbuffers::grpc::Message<ReceiveModelAndTensorResponse>* response, ::grpc::CompletionQueue* cq) {
  return ::grpc::internal::ClientAsyncWriterFactory< flatbuffers::grpc::Message<InputData>>::Create(channel_.get(), cq, rpcmethod_ReceiveModelAndTensor_, context, response, false, nullptr);
}

ModelService::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      ModelService_method_names[0],
      ::grpc::internal::RpcMethod::CLIENT_STREAMING,
      new ::grpc::internal::ClientStreamingHandler< ModelService::Service, flatbuffers::grpc::Message<InputData>, flatbuffers::grpc::Message<ReceiveModelAndTensorResponse>>(
          std::mem_fn(&ModelService::Service::ReceiveModelAndTensor), this)));
}

ModelService::Service::~Service() {
}

::grpc::Status ModelService::Service::ReceiveModelAndTensor(::grpc::ServerContext* /*context*/, ::grpc::ServerReader< flatbuffers::grpc::Message<InputData>>* /*reader*/, flatbuffers::grpc::Message<ReceiveModelAndTensorResponse>* /*response*/) {
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace myservice

